// This is a skeleton starter React component generated by Plasmic.
// Feel free to edit as you see fit.
import { DevContainer } from "@/wab/client/components/dev";
import { CopilotPanel } from "@/wab/client/components/sidebar-tabs/CopilotPanel";
import { OutlineTab } from "@/wab/client/components/sidebar-tabs/outline-tab";
import { ResponsivenessPanel } from "@/wab/client/components/sidebar-tabs/ResponsivenessPanel";
import { VersionsTab } from "@/wab/client/components/sidebar-tabs/versions-tab";
import { FindReferencesModal } from "@/wab/client/components/sidebar/FindReferencesModal";
import { ImageAssetsPanel } from "@/wab/client/components/sidebar/image-asset-controls";
import LeftComponentsPanel from "@/wab/client/components/sidebar/LeftComponentsPanel";
import LeftGeneralTokensPanel from "@/wab/client/components/sidebar/LeftGeneralTokensPanel";
import LeftLintIssuesPanel from "@/wab/client/components/sidebar/LeftLintIssuesPanel";
import LeftProjectSettingsPanel from "@/wab/client/components/sidebar/LeftProjectSettingsPanel";
import LeftSplitsPanel from "@/wab/client/components/sidebar/LeftSplitsPanel";

import { MixinsPanel } from "@/wab/client/components/sidebar/MixinControls";
import { ProjectDependenciesPanel } from "@/wab/client/components/sidebar/ProjectDependencies";
import { SidebarModalProvider } from "@/wab/client/components/sidebar/SidebarModal";
import { DefaultStylesPanel } from "@/wab/client/components/sidebar/ThemesControls";
import { UserManagedFontsPanel } from "@/wab/client/components/sidebar/UserManagedFonts";
import { providesSidebarPopupSetting } from "@/wab/client/components/style-controls/StyleComponent";
import { Icon } from "@/wab/client/components/widgets/Icon";
import { ListStack } from "@/wab/client/components/widgets/ListStack";
import { useResizableHandle } from "@/wab/client/hooks/useResizableHandle";
import ComponentIcon from "@/wab/client/plasmic/plasmic_kit/PlasmicIcon__Component";
import TokenIcon from "@/wab/client/plasmic/plasmic_kit/PlasmicIcon__Token";
import PlasmicLeftPane from "@/wab/client/plasmic/plasmic_kit_left_pane/PlasmicLeftPane";
import { StudioCtx } from "@/wab/client/studio-ctx/StudioCtx";
import { HighlightBlinker } from "@/wab/commons/components/HighlightBlinker";
import { useSignalListener } from "@/wab/commons/components/use-signal-listener";
import { XDraggable } from "@/wab/commons/components/XDraggable";
import {
  cx,
  ensure,
  isOneOf,
  maybe,
  spawn,
  swallow,
  spawnWrapper,
  switchType,
} from "@/wab/shared/common";
import {
  getComponentDisplayName,
  isHostLessCodeComponent,
  getRealParams,
  findVariantGroupForParam,
} from "@/wab/shared/core/components";
import { extractComponentUsages } from "@/wab/shared/core/sites";
import { extractTokenUsages } from "@/wab/shared/core/styles";
import { ENV } from "@/wab/shared/devflags";
import { Component, isKnownExpr, StyleToken } from "@/wab/shared/model/classes";
import { LeftTabKey } from "@/wab/shared/ui-config-utils";
import L from "lodash";
import { observer } from "mobx-react";
import React, { useEffect, useState } from "react";
import { useLocalStorage } from "react-use";
import { resolveTemplatedString } from "@/wab/client/components/sidebar-tabs/ComponentProps/TemplatedTextEditor";
import { codeLit, tryExtractJson, asCode } from "@/wab/shared/core/exprs";
import { Descendant } from "slate";
import {
  getPropTypeType,
  isPlainObjectPropType,
} from "@/wab/shared/code-components/code-components";
import { ComponentPropOrigin } from "@/wab/shared/core/lang";
import { tryGetTplOwnerComponent } from "@/wab/shared/core/tpls";
import { isSlot } from "@/wab/shared/SlotUtils";
import { paramToVarName } from "@/wab/shared/codegen/util";
import {
  CONTRACT_PACKAGE_ID_PARAM_NAME,
  CREATED_COLLECTION_PARAM_NAME,
  IMPORTED_COLLECTIONS_PARAM_NAME,
  MINTING_INFO_PARAM_NAME,
  WEB3_GLOBAL_CONTEXT_COMP_NAME,
} from "@/wab/client/constant/contract.constant";
import { NFTCollectionResponse } from "@/wab/shared/ApiSchema";
import { useQuery } from "@tanstack/react-query";
import { notification } from "antd";
import jsonrepair from "jsonrepair";

interface LeftPaneProps {
  studioCtx: StudioCtx;
  className?: string;
}

interface IAttribute {
  type: string;
  value: string;
}

interface ITeamMember {
  name: string;
  role: string;
  avatar?: string;
}

interface IWhitelistInfo {
  price: string;
  startTime: Date;
  endTime: Date | null;
  totalNFTs: number;
  maxNFTsPerWallet: number;
}

interface IPresaleConfig {
  startTime: Date;
  endTime: Date | null;
  totalSlots: number;
  whitelistInfo: IWhitelistInfo;
}

interface IPublicSaleConfig {
  price: string;
  startTime: Date;
  endTime: Date | null;
  totalNFTs: number;
  maxNFTsPerWallet: number;
}

interface IMintingInfo {
  name: string;
  description: string;
  royalty: string;
  milestones: string[];
  itemName: string;
  itemDescription: string;
  attributes: IAttribute[];
  teamMembers: ITeamMember[];
  hasPresale: boolean;
  presale: IPresaleConfig;
  hasPublicSale: boolean;
  publicSale: IPublicSaleConfig;
}

export type {
  IMintingInfo,
  IAttribute,
  ITeamMember,
  IWhitelistInfo,
  IPresaleConfig,
  IPublicSaleConfig,
};

const LeftPane = observer(function LeftPane(props: LeftPaneProps) {
  const { studioCtx } = props;
  const dbCtx = studioCtx.dbCtx();
  const tplMgr = studioCtx.tplMgr();
  const web3GlobalContextTpl = studioCtx.site.globalContexts.find(
    (item) => item.component.name === WEB3_GLOBAL_CONTEXT_COMP_NAME
  );

  const wrapTab = (
    tabKey: LeftTabKey,
    panel: React.ReactNode,
    unmount = false
  ) => {
    return (
      (!unmount || studioCtx.leftTabKey === tabKey) && (
        <div
          className="flex-col flex-fill overflow-hidden"
          style={tabKey === studioCtx.leftTabKey ? {} : { display: "none" }}
        >
          {panel}
        </div>
      )
    );
  };

  const leftPaneRef = React.useRef<HTMLDivElement>(null);

  const { onDragStart, onDrag, onDragStop } = useResizableHandle({
    panelRef: leftPaneRef,
    onChange: React.useCallback(
      (newWidth: number) => {
        spawn(
          studioCtx.changeUnsafe(() => {
            studioCtx.leftPaneWidth = newWidth;
          })
        );
      },
      [studioCtx]
    ),
  });

  const [dismissVersionsCTA, setDismissVersionsCTA] = useLocalStorage(
    `${studioCtx.siteInfo.id}-dismissVersionsCTA`,
    false
  );

  // revision number of latest published version
  const [latestPublishedRevNum, setLatestPublishedRevNum] = useState<number>();
  const latestPublishedVersion = L.head(studioCtx.releases);
  const [collection, setCollection] = useState<NFTCollectionResponse>();
  // Intergrating API for minting info
  const { data: launchpadCollection } = useQuery({
    queryKey: ["mintingInfo", studioCtx.siteInfo?.id || ""],
    queryFn: async () => {
      const res = await fetch(
        `${
          process.env.MARKETPLACE_API_URL_LAUCHPAD
        }launchpad/collections/project/${studioCtx.siteInfo?.id || ""}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      );

      if (!res.ok) {
        throw new Error("Failed to create launchpad");
      }

      const data = await res.json();

      // Check if data is available
      if (data.status !== "ACTIVE") {
        throw new Error("Data is not available");
      }

      return data;
    },
    enabled:
      !!studioCtx.siteInfo?.id &&
      studioCtx.siteInfo?.clonedFromProjectId ===
        process.env.TEMPLATE_PROJECT_ID_NFT_MINTING,
    retry: 5, // Retry 3 times,
    retryDelay: () => 2000, // 2 second delay between retries
  });

  // Check if we need to fetch latest data
  React.useEffect(() => {
    spawn(
      (async () => {
        const { rev: latestPublishedRev } = await studioCtx.getLatestVersion(
          latestPublishedVersion?.revisionId,
          latestPublishedVersion?.branchId ?? undefined
        );
        setLatestPublishedRevNum(latestPublishedRev?.revision);
      })()
    );
  }, [studioCtx, latestPublishedVersion]);

  // Check if we need to fetch latest data
  React.useEffect(() => {
    spawn(
      (async () => {
        const { rev: latestPublishedRev } = await studioCtx.getLatestVersion(
          latestPublishedVersion?.revisionId,
          latestPublishedVersion?.branchId ?? undefined
        );
        setLatestPublishedRevNum(latestPublishedRev?.revision);
      })()
    );
  }, [studioCtx, latestPublishedVersion]);

  React.useEffect(() => {
    spawn(
      (async () => {
        if (!studioCtx.siteInfo?.id) {
          return;
        }
        const { collections } =
          await studioCtx.appCtx.api.getProjectCollections(
            studioCtx.siteInfo?.id || ""
          );
        console.log("ðŸš€ ~ collections:", collections);

        if (collections) {
          setCollection(collections);
        }
      })()
    );
  }, [studioCtx.siteInfo.id]);

  const useVersionsCTA =
    !dismissVersionsCTA &&
    studioCtx.releases.length > 0 &&
    !!latestPublishedRevNum &&
    ensure(latestPublishedRevNum, "Should have latestPublishedRevNum") <
      dbCtx.revisionNum;

  const isLoggedIn = studioCtx.appCtx.selfInfo != null;

  const [highlightPane, setHighlightPane] = useState(false);

  useSignalListener(studioCtx.leftPanelHighlightingRequested, () => {
    setHighlightPane(true);
    setTimeout(() => setHighlightPane(false), 2000);
  });

  const component = web3GlobalContextTpl
    ? tryGetTplOwnerComponent(web3GlobalContextTpl) ?? null
    : null;

  const componentProps = web3GlobalContextTpl
    ? Object.fromEntries(
        web3GlobalContextTpl.vsettings[0].args
          .filter(
            (arg) =>
              !isSlot(arg.param) &&
              !findVariantGroupForParam(
                web3GlobalContextTpl.component,
                arg.param
              )
          )
          .map((arg) => [
            paramToVarName(web3GlobalContextTpl.component, arg.param),
            tryExtractJson(
              asCode(arg.expr, {
                projectFlags: studioCtx.projectFlags(),
                component,
                inStudio: true,
              })
            ),
          ])
      )
    : null;

  const params = web3GlobalContextTpl
    ? getRealParams(web3GlobalContextTpl.component).filter((param) => {
        const propType = (
          isHostLessCodeComponent(web3GlobalContextTpl.component)
            ? studioCtx.getHostLessContextsMap()
            : studioCtx.getRegisteredContextsMap()
        ).get(web3GlobalContextTpl.component.name)?.meta.props[
          param.variable.name
        ];
        const propTypeType = getPropTypeType(propType);
        if (
          propTypeType &&
          isOneOf(propTypeType, [
            "styleScopeClass",
            "themeResetClass",
            "themeStyles",
          ])
        ) {
          return false;
        }
        if (isPlainObjectPropType(propType) && propType.type !== "slot") {
          const objPropType = propType;
          return !swallow(() =>
            objPropType.hidden?.(componentProps, null, { path: [] })
          );
        }
        return param.origin !== ComponentPropOrigin.ReactHTMLAttributes;
      })
    : null;

  useEffect(() => {
    updateTextTemplate(CONTRACT_PACKAGE_ID_PARAM_NAME, ENV.CONTRACT_PACKAGE_ID);
  }, [web3GlobalContextTpl]);

  useEffect(() => {
    if (collection?.collectionId) {
      updateTextTemplate(
        IMPORTED_COLLECTIONS_PARAM_NAME,
        collection?.collectionId
      );
    }
  }, [collection?.collectionId]);

  const launchpadCollectionString = JSON.stringify(launchpadCollection);

  useEffect(() => {
    const stringifiedData = JSON.stringify(launchpadCollection);
    if (launchpadCollection?.id) {
      updateTextTemplate(
        CREATED_COLLECTION_PARAM_NAME,
        launchpadCollection?.id
      );

      console.log("ðŸš€ ~ useEffect ~ stringifiedData:", stringifiedData);
      updateObjectTemplate(MINTING_INFO_PARAM_NAME, stringifiedData);
    }
  }, [launchpadCollectionString]);

  const updateObjectTemplate = (name: string, value?: string) => {
    if (!web3GlobalContextTpl || !value) {
      return;
    }

    let val;
    try {
      val = jsonrepair(value);
    } catch {}

    if (val[0] !== "{") {
      notification.warn({
        message: "Invalid JSON object",
        description: "Only JSON objects (wrapped in {}) are supported.",
      });
      return false;
    }
    try {
      const expr = JSON.parse(val);

      const p = params?.find((item) => item.variable.name === name);

      if (!p) {
        return;
      }

      const newExpr = codeLit(expr);
      void studioCtx.change(({ success }) => {
        tplMgr.setArg(
          web3GlobalContextTpl,
          web3GlobalContextTpl.vsettings[0],
          p.variable,
          newExpr
        );
        return success();
      });
    } catch (err) {
      notification.warn({
        message: "Invalid JSON",
        description: `${err}`,
      });
      return;
    }
  };

  const updateTextTemplate = (name: string, value?: string) => {
    if (!web3GlobalContextTpl || !value) {
      return;
    }

    const nodes: Descendant[] = [
      {
        children: [{ text: value }],
        type: "paragraph",
      },
    ];
    const expr = resolveTemplatedString(nodes);

    const p = params?.find((item) => item.variable.name === name);

    if (!p) {
      return;
    }

    const arg = web3GlobalContextTpl.vsettings[0].args.find(
      (_arg) => _arg.param === p
    );
    const curExpr = maybe(arg, (x) => x.expr) || p.defaultExpr || undefined;

    const exprLit = curExpr ? tryExtractJson(curExpr) ?? curExpr : undefined;

    if (!!exprLit) {
      return;
    }

    if (expr == null && exprLit == null) {
      return;
    }
    const newExpr = isKnownExpr(expr) ? expr : codeLit(expr);
    void studioCtx.change(({ success }) => {
      tplMgr.setArg(
        web3GlobalContextTpl,
        web3GlobalContextTpl.vsettings[0],
        p.variable,
        newExpr
      );
      return success();
    });
  };

  return providesSidebarPopupSetting({ left: true })(
    <SidebarModalProvider containerSelector={".canvas-editor__left-pane"}>
      <DevContainer
        className={cx({
          flex: true,
          // monochrome: !hover,
          "canvas-editor__left-pane-container": true,
        })}
        style={{
          position: "relative",
        }}
        showControls={studioCtx.showDevControls}
        // onMouseEnter={() => setHover(true)}
        // onMouseLeave={() => setHover(false)}
      >
        {studioCtx.showAddDrawer() && (
          <div
            style={{
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: "#F9F9F8",
              zIndex: 9,
            }}
          />
        )}
        <PlasmicLeftPane
          leftTabStrip={{ props: { useVersionsCTA } }}
          type={studioCtx.leftTabKey}
          paneContainer={{
            props: {
              className: "canvas-editor__left-pane auto-pointer-events",
              style: !studioCtx.leftTabKey
                ? {
                    display: "none",
                  }
                : {
                    width: studioCtx.leftPaneWidth,
                  },
            },

            wrapChildren: (children) => (
              <>
                <ListStack>{children}</ListStack>
                <XDraggable
                  onStart={onDragStart}
                  onStop={onDragStop}
                  onDrag={onDrag}
                  minPx={0}
                >
                  <div className="left-pane-resizer auto-pointer-events" />
                </XDraggable>
              </>
            ),
          }}
          paneContent={{
            props: {
              ref: leftPaneRef,
              children: (
                <>
                  {wrapTab("responsiveness", <ResponsivenessPanel />)}
                  {wrapTab("outline", <OutlineTab />)}
                  {studioCtx.appCtx.appConfig.copilotTab &&
                    wrapTab("copilot", <CopilotPanel />)}
                  {wrapTab("tokens", <LeftGeneralTokensPanel />)}
                  {wrapTab("mixins", <MixinsPanel />)}
                  {wrapTab("components", <LeftComponentsPanel />)}
                  {wrapTab("themes", <DefaultStylesPanel />)}
                  {wrapTab("images", <ImageAssetsPanel />)}
                  {wrapTab("fonts", <UserManagedFontsPanel />)}

                  {isLoggedIn &&
                    wrapTab("imports", <ProjectDependenciesPanel />)}
                  {isLoggedIn &&
                    wrapTab(
                      "versions",
                      <VersionsTab
                        useVersionsCTA={useVersionsCTA}
                        dismissVersionsCTA={() => setDismissVersionsCTA(true)}
                      />
                    )}
                  {wrapTab("settings", <LeftProjectSettingsPanel />)}
                  {wrapTab("splits", <LeftSplitsPanel />)}
                  {wrapTab("lint", <LeftLintIssuesPanel />, true)}
                  {highlightPane && <HighlightBlinker />}
                </>
              ),
            },
          }}
        />
      </DevContainer>
      {(studioCtx.findReferencesComponent || studioCtx.findReferencesToken) && (
        <FindReferencesModal
          studioCtx={studioCtx}
          {...getFindReferencesProps(
            studioCtx,
            [
              studioCtx.findReferencesComponent,
              studioCtx.findReferencesToken,
            ].find((x) => x != null) as Component | StyleToken
          )}
        />
      )}
    </SidebarModalProvider>
  );
});

const getFindReferencesProps = (
  studioCtx: StudioCtx,
  reference: Component | StyleToken
) => {
  return switchType(reference)
    .when(Component, (component) => ({
      displayName: getComponentDisplayName(component),
      icon: (
        <Icon
          icon={ComponentIcon}
          className="component-fg custom-svg-icon--lg monochrome-exempt"
        />
      ),
      usageSummary: extractComponentUsages(studioCtx.site, component),
      onClose: spawnWrapper(async () => {
        await studioCtx.changeUnsafe(
          () => (studioCtx.findReferencesComponent = undefined)
        );
      }),
    }))
    .when(StyleToken, (token) => ({
      displayName: token.name,
      icon: (
        <Icon
          icon={TokenIcon}
          className="token-fg custom-svg-icon--lg monochrome-exempt"
        />
      ),
      usageSummary: extractTokenUsages(studioCtx.site, token)[1],
      onClose: spawnWrapper(async () => {
        await studioCtx.changeUnsafe(
          () => (studioCtx.findReferencesToken = undefined)
        );
      }),
    }))
    .result();
};

export default LeftPane as React.FunctionComponent<LeftPaneProps>;
